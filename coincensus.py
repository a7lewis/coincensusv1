# Copyright 2017 Haptigram Software LLC

import fileinput
import glob, os
import logging, sys

import plotly.offline as py
import numpy as np
import pandas as pd
import zipcode
import re
from datetime import datetime

# this is a first iteration script that takes a quick and inelegant path to the goal of generating a choropleth map from bulk coin data.
# intended as a first draft, both to get quick results to show off to generate interest in potential crowd source data contributors, and reveal code design and workflow issues
# it is being replaced by a Django webapp that will offer user accounts/auth, web form for uploading csv data files, data validation and storage in sqlite, and autogenerated choropleth maps and other dynamic results based on that data
# http://coincensus.org - site hosting results from running this script against current data

class Coin:

	year = 2016
	mint = ''
	type = ''
	
	def __init__(self,year,mint,date):
		self.year = year
		self.mint = mint
		self.type = type

def processLine( list, line, lineindex, filename ):

	logger.debug( "row: " + str(lineindex) )
	cols = line.split(',')
	numcols = len(cols)
	logger.debug( "length of cols: " + str(len(cols)) )
	if numcols > 1:	
		date = cols[0]
		mint = cols[1].rstrip("\n")		
		x = Coin(date, mint, "nickel")	
		logger.debug( "year: " + x.year + " mint: " + x.mint )
		
		list.append(x)
	else:
		logger.error( "\t" + filename + " line " + str(lineindex) + " without commas, skip line")



# log setup
# todo command line param or something to switch log levels
# CRITICAL ERROR WARNING INFO DEBUG NOTSET
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler(sys.stdout)
ch.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)	

coinList = []

stateList = ('AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY')
statename = dict([
('AL','Alabama'),
('AK','Alaska'),
('AS','American Samoa'),
('AZ','Arizona'),
('AR','Arkansas'),
('CA','California'),
('CO','Colorado'),
('CT','Connecticut'),
('DE','Delaware'),
('DC','District of Columbia'),
('FM','Federated States of Micronesia'),
('FL','Florida'),
('GA','Georgia'),
('GU','Guam'),
('HI','Hawaii'),
('ID','Idaho'),
('IL','Illinois'),
('IN','Indiana'),
('IA','Iowa'),
('KS','Kansas'),
('KY','Kentucky'),
('LA','Louisiana'),
('ME','Maine'),
('MH','Marshall Islands'),
('MD','Maryland'),
('MA','Massachusetts'),
('MI','Michigan'),
('MN','Minnesota'),
('MS','Mississippi'),
('MO','Missouri'),
('MT','Montana'),
('NE','Nebraska'),
('NV','Nevada'),
('NH','New Hampshire'),
('NJ','New Jersey'),
('NM','New Mexico'),
('NY','New York'),
('NC','North Carolina'),
('ND','North Dakota'),
('MP','Northern Mariana Islands'),
('OH','Ohio'),
('OK','Oklahoma'),
('OR','Oregon'),
('PW','Palau'),
('PA','Pennsylvania'),
('PR','Puerto Rico'),
('RI','Rhode Island'),
('SC','South Carolina'),
('SD','South Dakota'),
('TN','Tennessee'),
('TX','Texas'),
('UT','Utah'),
('VT','Vermont'),
('VI','Virgin Islands'),
('VA','Virginia'),
('WA','Washington'),
('WV','West Virginia'),
('WI','Wisconsin'),
('WY','Wyoming')
])

pcount = dict((st,0) for st in stateList)
dcount = dict((st,0) for st in stateList)
scount = dict((st,0) for st in stateList)
acount = dict((st,0) for st in stateList)

# python coincount.py
# todo 
# x - change from one file to a directory of files
# 1 - parameterize type of coin as input argument "penny", "nickel"
# 1a - use coin type to determine which files to process
# 1b - determine zip, datestamp from filename, use those to store raw data
# x 2 figure out how to generate a choropleth map
# x 3 put it in the cloud! amazon aws webserver to show maps
#     upload sample csv file, get base url to redirect to main page
# 4 - proper data store for raw coin data (something that can handle csv and restful one-offs
# 5 - rest interface for account creation, auth, raw data upload (location,datestamp,type,year,mint,condition,variety,notes)
# 6 - mobile app as interface for rest

# x 4/20/17 logging print stmts, log files use python logging module
# x 4/20 - changed choropleth color schema to gradient between dark green P and dark red D

for filename in os.listdir("./"):
	if filename.endswith(".csv"):
		#print file
		file = open(filename)
		logger.info(filename)

# parse out zip code - use that to determine state (later county??) 
# address ambiguity in general must be robust - latlong, address, zip or county, state
# reject any data which does not at least have state
# BUG - this is brittle - mistakenly picks up yyyymmdd if it precedes zipcode, need to tighten regex or tighten csv naming convention rules
		zipmatch = re.search('\d{5}',filename)
		if zipmatch == None:
			logger.error( filename +  " no zip code found, skipping" )
			continue
		zipcodestr = zipmatch.group(0)
		logger.info( "\tzip: " + zipcodestr )
		
		# parse datestamp
		# BUG blows up on bogus dates eg 20171313 - no 13th month
		datematch = re.search('\d{8}',filename)
		if datematch == None:
			logger.error( filename + " no date string found, skipping" )
			continue
		datestr = datematch.group(0)
		logger.debug("datestr: " + datestr)
		filedate = datetime.strptime( datestr, "%Y%m%d" )
		logger.info( "\tdate object: " + str(filedate) )
		
		# 4/21 parse coin type out of csv filename
		cointypestr = ""	
		match_penn = re.search('penn',filename,re.IGNORECASE)
		match_nickel = re.search('nickel',filename,re.IGNORECASE)
		match_dime = re.search('dime',filename,re.IGNORECASE)
		match_quarter = re.search('quarter',filename,re.IGNORECASE)
		match_half = re.search('half',filename,re.IGNORECASE)
		match_dollar = re.search('dollar',filename,re.IGNORECASE)
		if match_penn != None:
			cointypestr = "penny"
		elif match_nickel != None:
			cointypestr = "nickel"
		elif match_dime != None:
			cointypestr = "dime"
		elif match_quarter != None:
			cointypestr = "quarter"
		elif match_half != None:
			cointypestr = "half"
		elif match_dollar != None:
			cointypestr = "dollar"
		else:
			logger.error( filename + " no coin type found, skipping" )
			continue
		
		logger.info( "\tcoin type: " + cointypestr )
		
		# zip code lookup - TODO error handling
		# TODO also update zipcode package from github, 2.0.0 on pypi.python.org is out of date and missing many zip codes such as most of VA like 22627
		zipcodeobj = zipcode.isequal(zipcodestr)
		statekey = zipcodeobj.state
		logger.info( "\t" + statekey + ", " + statename[ statekey ] )
		
		# new list for each file
		del coinList[:]

		li = 0
		for line in file:
			processLine(coinList,line,li,filename)
			li += 1
		
		# totals in the file processed	
		asum = len( coinList )
		dsum = sum( x.mint == "d" for x in coinList )
		psum = sum( x.mint == "p" for x in coinList )
		bsum = sum( x.mint == ""  for x in coinList )
		ssum = sum( x.mint == "s" for x in coinList )
		
		# running totals per state for each mintage
		pcount[statekey] = pcount[statekey] + ( bsum + psum )
		dcount[statekey] = dcount[statekey] + ( dsum )
		scount[statekey] = scount[statekey] + ( ssum )
		acount[statekey] = acount[statekey] + ( asum )
		
		logger.info( "\tpsum: " + str(bsum + psum) + " dsum: " + str(dsum) + " ssum: " + str(ssum) + " total: " + str(asum) )				
	



# todo - parse collection year off of input file
yearNow = 2016;

# this shows the year distribution going backward (ignore for now)
for n in range(yearNow,1900,-1):
	# exact match date stats
	op = sum( int(c.year) == n and (c.mint == '' or c.mint == 'p') for c in coinList )
	od = sum( int(c.year) == n and c.mint == 'd' for c in coinList )
	
	# omit years where no p or d was found
	if op + od > 0:
		dper = (100 * od / float(op + od))
		# number of years ago, %d
		#print str( yearNow + 1 - n ) + ", "  + "%.2f" % dper + ", " 
		
		# number of years [year], p, d, d%
		#print str( yearNow + 1 - n ) + ", " + " [" + str(n) + "], " + str(op) + ", " + str(od) + ", " + "%.2f" % dper + ", " 
		
					
	# younger than date
	#op = sum( int(c.year) >= n and (c.mint == '' or c.mint == 'p') for c in coinList )
	#od = sum( int(c.year) >= n and c.mint == 'd' for c in coinList )
	#if op + od > 0:
	#	dper = (od / float(op + od))	
	#	print str(n) + "," + str(op) + "," + str(od) + ":%.2f" % ( dper )
	

# now lets try some plotly	
# try making our own dataframe in memory

statePlotCount = 0
statelist = []
for sn in acount.keys():
	if acount[sn] > 0:
		statePlotCount += 1
		logger.info("statetuple: " + sn)
		statetuple = (sn, statename[sn], pcount[sn] / float(acount[sn]), pcount[sn], dcount[sn], scount[sn], acount[sn])
		statelist.append(statetuple)
d = np.zeros((statePlotCount),dtype=[('code','a2'),('state','a26'),('pratio','float16'),('philadelphia','i4'),('denver','i4'),('san francisco','i4'),('total','i4')])	
d[:] = statelist
df = pd.DataFrame(d)
	
for col in df.columns:
	df[col] = df[col].astype(str)
	
# this is a mix of 0.0 dark red - 1.0 dark green	
scl = [\
[0.0, 'rgb(128,0,38)'],\
[0.125, 'rgb(189,0,38)'],\
[0.25, 'rgb(227,26,28)'],\
[0.375, 'rgb(252,78,42)'],\
[0.5, 'rgb(127,127,55)'],\
[0.625, 'rgb(70,139,69)'],\
[0.75, 'rgb(35,139,69)'],\
[0.875, 'rgb(0,109,44)'],\
[1.0, 'rgb(0,68,27)']\
]

df['text'] = df['state'] + \
	'<br>' + 'Total ' + df['total'] +\
	'<br>' + 'Phila ' + df['philadelphia'] +\
	'<br>' + 'Denver ' + df['denver'] +\
	'<br>' + 'San Francisco ' + df['san francisco']
	
data = [ dict(
        type='choropleth',
        colorscale = scl,
        autocolorscale = False,
        locations = df['code'],
        z = df['pratio'].astype(float),
        locationmode = 'USA-states',
        text = df['text'],
        marker = dict(
            line = dict (
                color = 'rgb(255,255,255)',
                width = 2
            ) ),
        colorbar = dict(
            title = "P ratio")
        ) ]

#todo as part of functions/methods for maps, parameterize the title
#also determine the content of the title from the data analyzed

layout = dict(
        title = '2016-2017 Coin P ratio by State<br>(Hover for breakdown)',
        geo = dict(
            scope='usa',
            projection=dict( type='albers usa' ),
            showlakes = True,
            lakecolor = 'rgb(255, 255, 255)'),
             )
    
fig = dict( data=data, layout=layout )
py.plot( fig )


# Copyright 2017 Haptigram Software LLC